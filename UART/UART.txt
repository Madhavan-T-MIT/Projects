///////////////////////////////////////// UART TOP MODULE ///////////////////////////////////////////

module uart_top (
    input  wire clk,
    input  wire uart_rx,
    output wire uart_tx
);

    wire       rx_dv;         
    wire [7:0] rx_byte;       
    wire       tx_active;     


    reg [7:0] rbuf = 8'd0;
    reg       send_req = 1'b0;

    wire [7:0] tdata;
    wire       tvalid;

    uart_rx RX (
        .clk(clk),
        .rx_serial(uart_rx),
        .rx_dv(rx_dv),
        .rx_byte(rx_byte)
    );


    always @(posedge clk) begin
       
        if (rx_dv) begin
            rbuf <= rx_byte;
            send_req <= 1'b1;
        end

        if (send_req && ~tx_active) begin
            send_req <= 1'b0; 
        end
    end

    assign tdata  = rbuf;
    assign tvalid = send_req & ~tx_active;

    
    uart_tx TX (
        .clk(clk),
        .tx_dv(tvalid),
        .tx_byte(tdata),
        .tx_serial(uart_tx),
        .tx_active(tx_active)
    );

endmodule


//////////////////////////////////////// UART TRANSMITTER ///////////////////////////////////////////
module uart_tx (
    input  wire clk,
    input  wire tx_dv,
    input  wire [7:0] tx_byte,
    output reg  tx_serial,
    output reg  tx_active
);

    parameter CLKS_PER_BIT = 868;

    localparam IDLE    = 3'd0,
               START   = 3'd1,
               DATA    = 3'd2,
               STOP    = 3'd3,
               CLEANUP = 3'd4;

    reg [2:0]  state = IDLE;
    reg [13:0] clk_cnt = 0;
    reg [2:0]  bit_idx = 0;
    reg [7:0]  tx_shift;

    always @(posedge clk) begin
        case (state)
            IDLE: begin
                tx_serial <= 1'b1;
                tx_active <= 1'b0;
                clk_cnt <= 0;
                bit_idx <= 0;

                if (tx_dv) begin
                    tx_shift <= tx_byte;
                    tx_active <= 1'b1;
                    state <= START;
                end
            end

            START: begin
                tx_serial <= 1'b0;
                if (clk_cnt == CLKS_PER_BIT-1) begin
                    clk_cnt <= 0;
                    state <= DATA;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            DATA: begin
                tx_serial <= tx_shift[bit_idx];
                if (clk_cnt == CLKS_PER_BIT-1) begin
                    clk_cnt <= 0;
                    if (bit_idx == 3'd7) begin
                        bit_idx <= 0;
                        state <= STOP;
                    end else
                        bit_idx <= bit_idx + 1;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            STOP: begin
                tx_serial <= 1'b1;
                if (clk_cnt == CLKS_PER_BIT-1) begin
                    clk_cnt <= 0;
                    state <= CLEANUP;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            CLEANUP: begin
                tx_active <= 1'b0;
                state <= IDLE;
            end
        endcase
    end
endmodule


/////////////////////////////////// UART RECEIVER /////////////////////////////
module uart_rx (
    input  wire clk,
    input  wire rx_serial,
    output reg  rx_dv,
    output reg [7:0] rx_byte
);

    parameter CLKS_PER_BIT = 868;

    localparam IDLE    = 3'd0,
               START   = 3'd1,
               DATA    = 3'd2,
               STOP    = 3'd3,
               CLEANUP = 3'd4;

    reg [2:0]  state = IDLE;
    reg [13:0] clk_cnt = 0;
    reg [2:0]  bit_idx = 0;


    reg rx_sync1, rx_sync2;
    always @(posedge clk) begin
        rx_sync1 <= rx_serial;
        rx_sync2 <= rx_sync1;
    end

    always @(posedge clk) begin
        rx_dv <= 1'b0;

        case (state)
            IDLE: begin
                clk_cnt <= 0;
                bit_idx <= 0;
                if (rx_sync2 == 1'b0)
                    state <= START;
            end

            START: begin
                if (clk_cnt == (CLKS_PER_BIT-1)/2) begin
                    if (rx_sync2 == 1'b0) begin
                        clk_cnt <= 0;
                        state <= DATA;
                    end else
                        state <= IDLE;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            DATA: begin
                if (clk_cnt == CLKS_PER_BIT-1) begin
                    clk_cnt <= 0;
                    rx_byte[bit_idx] <= rx_sync2;
                    if (bit_idx == 3'd7) begin
                        bit_idx <= 0;
                        state <= STOP;
                    end else
                        bit_idx <= bit_idx + 1;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            STOP: begin
                if (clk_cnt == CLKS_PER_BIT-1) begin
                    clk_cnt <= 0;
                    state <= CLEANUP;
                end else
                    clk_cnt <= clk_cnt + 1;
            end

            CLEANUP: begin
                rx_dv <= 1'b1;   
                state <= IDLE;
            end
        endcase
    end
endmodule
///////////////////////////////////////// UART TESTBENCH //////////////////////////////////////

`timescale 1ns/1ps

module tb_uart;

    reg clk = 0;
    always #5 clk = ~clk;  // 100 MHz


    reg  uart_rx;
    wire uart_tx;

    uart_top DUT (
        .clk(clk),
        .uart_rx(uart_rx),
        .uart_tx(uart_tx)
    );

   
    localparam CLKS_PER_BIT = 868;
    localparam BIT_TIME = CLKS_PER_BIT * 10;

   
    reg [7:0] expected;
    reg [7:0] received;

    // -------------------------------------------------
    // UART DRIVER (stimulus)
    // -------------------------------------------------
    task uart_send_byte(input [7:0] data);
        integer i;
        begin
            uart_rx = 1'b1;
           #(BIT_TIME);
            

            // Start bit
            uart_rx = 1'b0;
            #(BIT_TIME);
           

            // Data bits
            for (i = 0; i < 8; i = i + 1) begin
               uart_rx = data[i];
                #(BIT_TIME);
               
            end

            // Stop bit
            uart_rx = 1'b1;
            #(BIT_TIME);
            
        end
    endtask

    // -------------------------------------------------
    // UART MONITOR (TX decode)
    // -------------------------------------------------
    task uart_capture_byte(output [7:0] data);
        integer i;
        begin
            // Wait start bit
            wait (uart_tx == 1'b0);

            #(BIT_TIME/2);// center start bit
                
            // Sample data bits
            for (i = 0; i < 8; i = i + 1) begin
                #(BIT_TIME);
                
               data[i] = uart_tx;
            end

            // Stop bit
            #(BIT_TIME);
            
        end
    endtask

    // -------------------------------------------------
    // TEST SEQUENCE
    // -------------------------------------------------
    initial begin
        uart_rx = 1'b1;

        repeat (5) @(posedge clk);

        // Test vectors
        repeat (10) begin
            expected = $random;
            fork
                uart_send_byte(expected);
                uart_capture_byte(received);
            join

            if (received !== expected) begin
                $error("UART FAIL: expected %h got %h", expected, received);
                $stop;
            end else begin
                $display("UART PASS: %h", received);
            end
        end

        //$display("ALL UART TESTS PASSED");
        $finish;
    end

endmodule
